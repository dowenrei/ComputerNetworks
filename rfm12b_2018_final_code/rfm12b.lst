
rfm12b.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000005e  00800100  000005be  00000652  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000005be  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000df  0080015e  0080015e  000006b0  2**0
                  ALLOC
  3 .stab         00001e6c  00000000  00000000  000006b0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001436  00000000  00000000  0000251c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00003952  2**0
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 4a 00 	jmp	0x94	; 0x94 <__ctors_end>
   4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
   8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
   c:	0c 94 87 00 	jmp	0x10e	; 0x10e <__vector_3>
  10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  18:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  28:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  2c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  48:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  50:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  60:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  64:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  6c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  70:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
  78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

0000007c <_ZL9init_cmds>:
  7c:	d6 80 01 82 f4 a4 02 c6 2d 94 ab c2 81 ca f7 c4     ........-.......
  8c:	70 98 00 c8 00 e0 81 82                             p.......

00000094 <__ctors_end>:
  94:	11 24       	eor	r1, r1
  96:	1f be       	out	0x3f, r1	; 63
  98:	cf ef       	ldi	r28, 0xFF	; 255
  9a:	d0 e1       	ldi	r29, 0x10	; 16
  9c:	de bf       	out	0x3e, r29	; 62
  9e:	cd bf       	out	0x3d, r28	; 61

000000a0 <__do_copy_data>:
  a0:	11 e0       	ldi	r17, 0x01	; 1
  a2:	a0 e0       	ldi	r26, 0x00	; 0
  a4:	b1 e0       	ldi	r27, 0x01	; 1
  a6:	ee eb       	ldi	r30, 0xBE	; 190
  a8:	f5 e0       	ldi	r31, 0x05	; 5
  aa:	02 c0       	rjmp	.+4      	; 0xb0 <__do_copy_data+0x10>
  ac:	05 90       	lpm	r0, Z+
  ae:	0d 92       	st	X+, r0
  b0:	ae 35       	cpi	r26, 0x5E	; 94
  b2:	b1 07       	cpc	r27, r17
  b4:	d9 f7       	brne	.-10     	; 0xac <__do_copy_data+0xc>

000000b6 <__do_clear_bss>:
  b6:	12 e0       	ldi	r17, 0x02	; 2
  b8:	ae e5       	ldi	r26, 0x5E	; 94
  ba:	b1 e0       	ldi	r27, 0x01	; 1
  bc:	01 c0       	rjmp	.+2      	; 0xc0 <.do_clear_bss_start>

000000be <.do_clear_bss_loop>:
  be:	1d 92       	st	X+, r1

000000c0 <.do_clear_bss_start>:
  c0:	ad 33       	cpi	r26, 0x3D	; 61
  c2:	b1 07       	cpc	r27, r17
  c4:	e1 f7       	brne	.-8      	; 0xbe <.do_clear_bss_loop>
  c6:	0e 94 54 02 	call	0x4a8	; 0x4a8 <main>
  ca:	0c 94 dd 02 	jmp	0x5ba	; 0x5ba <_exit>

000000ce <__bad_interrupt>:
  ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <_ZL10rfm12_dataj>:


//non-inlined version of rfm12_data
//warning: without the attribute, gcc will inline this even if -Os is set
static void __attribute__ ((noinline)) rfm12_data(uint16_t d) {
	SS_ASSERT();
  d2:	2c 98       	cbi	0x05, 4	; 5
	#if !(RFM12_SPI_SOFTWARE)
		SPDR = d >> 8;
  d4:	9e bd       	out	0x2e, r25	; 46
		while (!(SPSR & (1<<SPIF)));
  d6:	0d b4       	in	r0, 0x2d	; 45
  d8:	07 fe       	sbrs	r0, 7
  da:	fd cf       	rjmp	.-6      	; 0xd6 <_ZL10rfm12_dataj+0x4>

		SPDR = d & 0xff;
  dc:	8e bd       	out	0x2e, r24	; 46
		while (!(SPSR & (1<<SPIF)));
  de:	0d b4       	in	r0, 0x2d	; 45
  e0:	07 fe       	sbrs	r0, 7
  e2:	fd cf       	rjmp	.-6      	; 0xde <_ZL10rfm12_dataj+0xc>
	#else
		spi_data(d >> 8);
		spi_data(d & 0xff);
	#endif
	SS_RELEASE();
  e4:	2c 9a       	sbi	0x05, 4	; 5
  e6:	08 95       	ret

000000e8 <_ZL10rfm12_readj>:

//non-inlined version of rfm12_read
//warning: without the attribute, gcc will inline this even if -Os is set
static uint16_t __attribute__ ((noinline)) rfm12_read(uint16_t c) {
	uint16_t retval;
	SS_ASSERT();
  e8:	2c 98       	cbi	0x05, 4	; 5

	#if !(RFM12_SPI_SOFTWARE)
		SPDR = c >> 8;
  ea:	9e bd       	out	0x2e, r25	; 46
		while (!(SPSR & (1<<SPIF)));
  ec:	0d b4       	in	r0, 0x2d	; 45
  ee:	07 fe       	sbrs	r0, 7
  f0:	fd cf       	rjmp	.-6      	; 0xec <_ZL10rfm12_readj+0x4>
		retval = SPDR << 8;
  f2:	2e b5       	in	r18, 0x2e	; 46
  f4:	30 e0       	ldi	r19, 0x00	; 0
  f6:	32 2f       	mov	r19, r18
  f8:	22 27       	eor	r18, r18
		SPDR = c & 0xff;
  fa:	8e bd       	out	0x2e, r24	; 46
		while (!(SPSR & (1<<SPIF)));
  fc:	0d b4       	in	r0, 0x2d	; 45
  fe:	07 fe       	sbrs	r0, 7
 100:	fd cf       	rjmp	.-6      	; 0xfc <_ZL10rfm12_readj+0x14>
		retval |= SPDR;
 102:	8e b5       	in	r24, 0x2e	; 46
	#else
		retval = spi_data(c >> 8);
		retval <<= 8;
		retval |= spi_data(c & 0xff);
	#endif
	SS_RELEASE();
 104:	2c 9a       	sbi	0x05, 4	; 5
	return retval;
}
 106:	a9 01       	movw	r20, r18
 108:	48 2b       	or	r20, r24
 10a:	ca 01       	movw	r24, r20
 10c:	08 95       	ret

0000010e <__vector_3>:
#if (RFM12_USE_POLLING)
void rfm12_poll(void)
#else
ISR(RFM12_INT_VECT, ISR_NOBLOCK)
#endif
{
 10e:	78 94       	sei
 110:	1f 92       	push	r1
 112:	0f 92       	push	r0
 114:	0f b6       	in	r0, 0x3f	; 63
 116:	0f 92       	push	r0
 118:	11 24       	eor	r1, r1
 11a:	ff 92       	push	r15
 11c:	0f 93       	push	r16
 11e:	1f 93       	push	r17
 120:	2f 93       	push	r18
 122:	3f 93       	push	r19
 124:	4f 93       	push	r20
 126:	5f 93       	push	r21
 128:	6f 93       	push	r22
 12a:	7f 93       	push	r23
 12c:	8f 93       	push	r24
 12e:	9f 93       	push	r25
 130:	af 93       	push	r26
 132:	bf 93       	push	r27
 134:	cf 93       	push	r28
 136:	df 93       	push	r29
 138:	ef 93       	push	r30
 13a:	ff 93       	push	r31
	RFM12_INT_OFF();
 13c:	ea 98       	cbi	0x1d, 2	; 29
	#endif /* !(RFM12_TRANSMIT_ONLY) */

	do {
		//clear AVR int flag
#ifdef __PLATFORM_AVR__
		RFM12_INT_FLAG = (1<<RFM12_FLAG_BIT);
 13e:	04 e0       	ldi	r16, 0x04	; 4
						#if RFM12_UART_DEBUG >= 2
							put_ch('D');
						#endif

						//indicate that the buffer is ready to be used
						rf_rx_buffers[ctrl.buffer_in_num].status = STATUS_COMPLETE;
 140:	d2 e2       	ldi	r29, 0x22	; 34
 142:	22 e0       	ldi	r18, 0x02	; 2
 144:	f2 2e       	mov	r15, r18
					//if receive mode is not disabled (default)
					#if !(RFM12_TRANSMIT_ONLY)
						uint8_t data;

						//init the bytecounter - remember, we will read the length byte, so this must be 1
						ctrl.bytecount = 1;
 146:	11 e0       	ldi	r17, 0x01	; 1
	#endif /* !(RFM12_TRANSMIT_ONLY) */

	do {
		//clear AVR int flag
#ifdef __PLATFORM_AVR__
		RFM12_INT_FLAG = (1<<RFM12_FLAG_BIT);
 148:	0c bb       	out	0x1c, r16	; 28
/* @description reads the upper 8 bits of the status
 * register (the interrupt flags)
 */
static uint8_t rfm12_read_int_flags_inline(void) {
	#if !(RFM12_SPI_SOFTWARE)
		SS_ASSERT();
 14a:	2c 98       	cbi	0x05, 4	; 5
		SPDR = 0;
 14c:	1e bc       	out	0x2e, r1	; 46
		while (!(SPSR & (1<<SPIF)));
 14e:	0d b4       	in	r0, 0x2d	; 45
 150:	07 fe       	sbrs	r0, 7
 152:	fd cf       	rjmp	.-6      	; 0x14e <__vector_3+0x40>
		SS_RELEASE();
 154:	2c 9a       	sbi	0x05, 4	; 5
			put_ch('S');
			put_ch(status);
		#endif

		//check if the fifo interrupt occurred
		if (status & (RFM12_STATUS_FFIT>>8)) {
 156:	0e b4       	in	r0, 0x2e	; 46
 158:	07 fe       	sbrs	r0, 7
 15a:	79 c0       	rjmp	.+242    	; 0x24e <__vector_3+0x140>
			//yes
			recheck_interrupt = 1;
			//see what we have to do (start rx, rx or tx)
			switch (ctrl.rfm12_state) {
 15c:	c0 91 c6 01 	lds	r28, 0x01C6
 160:	c1 30       	cpi	r28, 0x01	; 1
 162:	f9 f0       	breq	.+62     	; 0x1a2 <__vector_3+0x94>
 164:	20 f0       	brcs	.+8      	; 0x16e <__vector_3+0x60>
 166:	c2 30       	cpi	r28, 0x02	; 2
 168:	09 f4       	brne	.+2      	; 0x16c <__vector_3+0x5e>
 16a:	4b c0       	rjmp	.+150    	; 0x202 <__vector_3+0xf4>
 16c:	65 c0       	rjmp	.+202    	; 0x238 <__vector_3+0x12a>
					//if receive mode is not disabled (default)
					#if !(RFM12_TRANSMIT_ONLY)
						uint8_t data;

						//init the bytecounter - remember, we will read the length byte, so this must be 1
						ctrl.bytecount = 1;
 16e:	10 93 c9 01 	sts	0x01C9, r17

						//read the length byte,  and write it to the checksum
						//remember, the first byte is the length byte
						data = rfm12_read(RFM12_CMD_READ);
 172:	80 e0       	ldi	r24, 0x00	; 0
 174:	90 eb       	ldi	r25, 0xB0	; 176
 176:	0e 94 74 00 	call	0xe8	; 0xe8 <_ZL10rfm12_readj>
						checksum = data;
 17a:	80 93 3c 02 	sts	0x023C, r24

						//add the packet overhead and store it into a working variable
						ctrl.num_bytes = data + PACKET_OVERHEAD;
 17e:	93 e0       	ldi	r25, 0x03	; 3
 180:	98 0f       	add	r25, r24
 182:	90 93 c8 01 	sts	0x01C8, r25
							put_ch(data);
						#endif

						//see whether our buffer is free
						//FIXME: put this into global statekeeping struct, the free state can be set by the function which pulls the packet, i guess
						if (rf_rx_buffers[ctrl.buffer_in_num].status == STATUS_FREE) {
 186:	e0 91 ca 01 	lds	r30, 0x01CA
 18a:	de 9f       	mul	r29, r30
 18c:	f0 01       	movw	r30, r0
 18e:	11 24       	eor	r1, r1
 190:	ec 52       	subi	r30, 0x2C	; 44
 192:	fe 4f       	sbci	r31, 0xFE	; 254
 194:	90 81       	ld	r25, Z
 196:	91 11       	cpse	r25, r1
 198:	4f c0       	rjmp	.+158    	; 0x238 <__vector_3+0x12a>
							//the current receive buffer is empty, so we start receiving
							ctrl.rfm12_state = STATE_RX_ACTIVE;
 19a:	10 93 c6 01 	sts	0x01C6, r17

							//store the received length into the packet buffer
							//this length field will be used by application reading the
							//buffer.
							rf_rx_buffers[ctrl.buffer_in_num].len = data;
 19e:	81 83       	std	Z+1, r24	; 0x01

							//end the interrupt without resetting the fifo
							goto no_fifo_reset;
 1a0:	d3 cf       	rjmp	.-90     	; 0x148 <__vector_3+0x3a>
				case STATE_RX_ACTIVE: {
					//if receive mode is not disabled (default)
					#if !(RFM12_TRANSMIT_ONLY)
						uint8_t data;
						//read a byte
						data = rfm12_read(RFM12_CMD_READ);
 1a2:	80 e0       	ldi	r24, 0x00	; 0
 1a4:	90 eb       	ldi	r25, 0xB0	; 176
 1a6:	0e 94 74 00 	call	0xe8	; 0xe8 <_ZL10rfm12_readj>

						//check if transmission is complete
						if (ctrl.bytecount < ctrl.num_bytes) {
 1aa:	90 91 c9 01 	lds	r25, 0x01C9
 1ae:	20 91 c8 01 	lds	r18, 0x01C8
 1b2:	92 17       	cp	r25, r18
 1b4:	d0 f4       	brcc	.+52     	; 0x1ea <__vector_3+0xdc>
								put_ch(data);
							#endif

							//xor the remaining bytes onto the checksum
							//note: only the header will be effectively checked
							checksum ^= data;
 1b6:	20 91 3c 02 	lds	r18, 0x023C
 1ba:	28 27       	eor	r18, r24
 1bc:	20 93 3c 02 	sts	0x023C, r18

							//put next byte into buffer, if there is enough space
							if (ctrl.bytecount < (RFM12_RX_BUFFER_SIZE + 3)) {
 1c0:	91 32       	cpi	r25, 0x21	; 33
 1c2:	20 f0       	brcs	.+8      	; 0x1cc <__vector_3+0xbe>
								break;
							}
                                                        #endif

							//increment bytecount
							ctrl.bytecount++;
 1c4:	9f 5f       	subi	r25, 0xFF	; 255
 1c6:	90 93 c9 01 	sts	0x01C9, r25

							//end the interrupt without resetting the fifo
							goto no_fifo_reset;
 1ca:	be cf       	rjmp	.-132    	; 0x148 <__vector_3+0x3a>
							checksum ^= data;

							//put next byte into buffer, if there is enough space
							if (ctrl.bytecount < (RFM12_RX_BUFFER_SIZE + 3)) {
								//hackhack: begin writing to struct at offsetof len
								(& rf_rx_buffers[ctrl.buffer_in_num].len)[ctrl.bytecount] = data;
 1cc:	e0 91 ca 01 	lds	r30, 0x01CA
 1d0:	de 9f       	mul	r29, r30
 1d2:	f0 01       	movw	r30, r0
 1d4:	11 24       	eor	r1, r1
 1d6:	eb 52       	subi	r30, 0x2B	; 43
 1d8:	fe 4f       	sbci	r31, 0xFE	; 254
 1da:	e9 0f       	add	r30, r25
 1dc:	f1 1d       	adc	r31, r1
 1de:	80 83       	st	Z, r24
							}
                                                        #ifndef DISABLE_CHECKSUMM
							//check header against checksum
							if (ctrl.bytecount == 2 && checksum != 0xff) {
 1e0:	92 30       	cpi	r25, 0x02	; 2
 1e2:	81 f7       	brne	.-32     	; 0x1c4 <__vector_3+0xb6>
 1e4:	2f 3f       	cpi	r18, 0xFF	; 255
 1e6:	41 f5       	brne	.+80     	; 0x238 <__vector_3+0x12a>
 1e8:	ed cf       	rjmp	.-38     	; 0x1c4 <__vector_3+0xb6>
						#if RFM12_UART_DEBUG >= 2
							put_ch('D');
						#endif

						//indicate that the buffer is ready to be used
						rf_rx_buffers[ctrl.buffer_in_num].status = STATUS_COMPLETE;
 1ea:	80 91 ca 01 	lds	r24, 0x01CA
 1ee:	d8 9f       	mul	r29, r24
 1f0:	f0 01       	movw	r30, r0
 1f2:	11 24       	eor	r1, r1
 1f4:	ec 52       	subi	r30, 0x2C	; 44
 1f6:	fe 4f       	sbci	r31, 0xFE	; 254
 1f8:	f0 82       	st	Z, r15
						}
						puts("Press D go back to main menu");*/
					

						//switch to other buffer
						ctrl.buffer_in_num ^= 1;
 1fa:	c8 27       	eor	r28, r24
 1fc:	c0 93 ca 01 	sts	0x01CA, r28

					#endif /* !(RFM12_TRANSMIT_ONLY) */
					} break;
 200:	1b c0       	rjmp	.+54     	; 0x238 <__vector_3+0x12a>
					//debug
					#if RFM12_UART_DEBUG >= 2
						put_ch('T');
					#endif

					if (ctrl.bytecount < ctrl.num_bytes) {
 202:	e0 91 c9 01 	lds	r30, 0x01C9
 206:	80 91 c8 01 	lds	r24, 0x01C8
 20a:	e8 17       	cp	r30, r24
 20c:	58 f4       	brcc	.+22     	; 0x224 <__vector_3+0x116>
						//load the next byte from our buffer struct.
						rfm12_data( RFM12_CMD_TX | rf_tx_buffer.sync[ctrl.bytecount++]);
 20e:	81 e0       	ldi	r24, 0x01	; 1
 210:	8e 0f       	add	r24, r30
 212:	80 93 c9 01 	sts	0x01C9, r24
 216:	f0 e0       	ldi	r31, 0x00	; 0
 218:	e8 5e       	subi	r30, 0xE8	; 232
 21a:	fd 4f       	sbci	r31, 0xFD	; 253
 21c:	80 81       	ld	r24, Z
 21e:	90 e0       	ldi	r25, 0x00	; 0
 220:	98 6b       	ori	r25, 0xB8	; 184
 222:	12 c0       	rjmp	.+36     	; 0x248 <__vector_3+0x13a>
					#ifdef TX_LEAVE_HOOK
						TX_LEAVE_HOOK;
					#endif

					//flag the buffer as free again
					ctrl.txstate = STATUS_FREE;
 224:	10 92 c7 01 	sts	0x01C7, r1
					#if RFM12_PWRMGT_SHADOW
						ctrl.pwrmgt_shadow &= ~(RFM12_PWRMGT_ET); /* disable transmitter */
						ctrl.pwrmgt_shadow |= (PWRMGT_RECEIVE);   /* activate predefined receive mode */
						rfm12_data(ctrl.pwrmgt_shadow);
					#else /* no RFM12_PWRMGT_SHADOW */
						rfm12_data( PWRMGT_RECEIVE );
 228:	81 e8       	ldi	r24, 0x81	; 129
 22a:	92 e8       	ldi	r25, 0x82	; 130
 22c:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZL10rfm12_dataj>
					#ifdef RX_ENTER_HOOK
						RX_ENTER_HOOK;
					#endif

					//load a dummy byte to clear int status
					rfm12_data( RFM12_CMD_TX | 0xaa);
 230:	8a ea       	ldi	r24, 0xAA	; 170
 232:	98 eb       	ldi	r25, 0xB8	; 184
 234:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZL10rfm12_dataj>
					break;

			}//end of switch

			//set the state machine to idle
			ctrl.rfm12_state = STATE_RX_IDLE;
 238:	10 92 c6 01 	sts	0x01C6, r1
			//reset the receiver fifo, if receive mode is not disabled (default)
			#if !(RFM12_TRANSMIT_ONLY)
				#if RFM12_UART_DEBUG >= 2
					put_ch('F');
				#endif
				rfm12_data( RFM12_CMD_FIFORESET | CLEAR_FIFO_INLINE);
 23c:	81 e8       	ldi	r24, 0x81	; 129
 23e:	9a ec       	ldi	r25, 0xCA	; 202
 240:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZL10rfm12_dataj>
				rfm12_data( RFM12_CMD_FIFORESET | ACCEPT_DATA_INLINE);
 244:	83 e8       	ldi	r24, 0x83	; 131
 246:	9a ec       	ldi	r25, 0xCA	; 202
 248:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZL10rfm12_dataj>
 24c:	7d cf       	rjmp	.-262    	; 0x148 <__vector_3+0x3a>
	#if RFM12_UART_DEBUG >= 2
		put_ch('E');
	#endif

	//turn the int back on
	RFM12_INT_ON();
 24e:	ea 9a       	sbi	0x1d, 2	; 29
}
 250:	ff 91       	pop	r31
 252:	ef 91       	pop	r30
 254:	df 91       	pop	r29
 256:	cf 91       	pop	r28
 258:	bf 91       	pop	r27
 25a:	af 91       	pop	r26
 25c:	9f 91       	pop	r25
 25e:	8f 91       	pop	r24
 260:	7f 91       	pop	r23
 262:	6f 91       	pop	r22
 264:	5f 91       	pop	r21
 266:	4f 91       	pop	r20
 268:	3f 91       	pop	r19
 26a:	2f 91       	pop	r18
 26c:	1f 91       	pop	r17
 26e:	0f 91       	pop	r16
 270:	ff 90       	pop	r15
 272:	0f 90       	pop	r0
 274:	0f be       	out	0x3f, r0	; 63
 276:	0f 90       	pop	r0
 278:	1f 90       	pop	r1
 27a:	18 95       	reti

0000027c <rfm12_start_tx>:
#else
uint8_t
#endif
rfm12_start_tx(uint8_t type, uint8_t length) {
	//exit if the buffer isn't free
	if (ctrl.txstate != STATUS_FREE)
 27c:	90 91 c7 01 	lds	r25, 0x01C7
 280:	91 11       	cpse	r25, r1
 282:	0d c0       	rjmp	.+26     	; 0x29e <rfm12_start_tx+0x22>
		return TXRETURN(RFM12_TX_OCCUPIED);

	//write airlab header to buffer
	rf_tx_buffer.len = length;
 284:	60 93 1a 02 	sts	0x021A, r22
	rf_tx_buffer.type = type;
 288:	80 93 1b 02 	sts	0x021B, r24
	rf_tx_buffer.checksum = length ^ type ^ 0xff;
 28c:	86 27       	eor	r24, r22
 28e:	80 95       	com	r24
 290:	80 93 1c 02 	sts	0x021C, r24

	//schedule packet for transmission
	ctrl.txstate = STATUS_OCCUPIED;
 294:	81 e0       	ldi	r24, 0x01	; 1
 296:	80 93 c7 01 	sts	0x01C7, r24

	return TXRETURN(RFM12_TX_ENQUEUED);
 29a:	80 e8       	ldi	r24, 0x80	; 128
 29c:	08 95       	ret
uint8_t
#endif
rfm12_start_tx(uint8_t type, uint8_t length) {
	//exit if the buffer isn't free
	if (ctrl.txstate != STATUS_FREE)
		return TXRETURN(RFM12_TX_OCCUPIED);
 29e:	83 e0       	ldi	r24, 0x03	; 3

	//schedule packet for transmission
	ctrl.txstate = STATUS_OCCUPIED;

	return TXRETURN(RFM12_TX_ENQUEUED);
}
 2a0:	08 95       	ret

000002a2 <rfm12_rx_clear>:
	* \see rfm12_rx_status(), rfm12_rx_len(), rfm12_rx_type(), rfm12_rx_buffer() and rf_rx_buffers
	*/
	//warning: without the attribute, gcc will inline this even if -Os is set
	void __attribute__((noinline)) rfm12_rx_clear(void) {
			//mark the current buffer as empty
			rf_rx_buffers[ctrl.buffer_out_num].status = STATUS_FREE;
 2a2:	ab ec       	ldi	r26, 0xCB	; 203
 2a4:	b1 e0       	ldi	r27, 0x01	; 1
 2a6:	9c 91       	ld	r25, X
 2a8:	82 e2       	ldi	r24, 0x22	; 34
 2aa:	98 9f       	mul	r25, r24
 2ac:	f0 01       	movw	r30, r0
 2ae:	11 24       	eor	r1, r1
 2b0:	ec 52       	subi	r30, 0x2C	; 44
 2b2:	fe 4f       	sbci	r31, 0xFE	; 254
 2b4:	10 82       	st	Z, r1

			//switch to the other buffer
			ctrl.buffer_out_num ^= 1;
 2b6:	81 e0       	ldi	r24, 0x01	; 1
 2b8:	89 27       	eor	r24, r25
 2ba:	8c 93       	st	X, r24
 2bc:	08 95       	ret

000002be <rfm12_init>:
* puts the module into receive mode before returning.
*
* \note Please note that the transmit power and receive amplification values are currently hard coded.
* Have a look into rfm12_hw.h for possible settings.
*/
void rfm12_init(void) {
 2be:	cf 93       	push	r28
 2c0:	df 93       	push	r29
	//initialize spi
#ifdef __PLATFORM_AVR__
	SS_RELEASE();
 2c2:	2c 9a       	sbi	0x05, 4	; 5
	DDR_SS |= (1<<BIT_SS);
 2c4:	24 9a       	sbi	0x04, 4	; 4
		return d;
	#endif
}

static void spi_init(void) {
	DDR_MOSI |= (_BV(BIT_MOSI));
 2c6:	25 9a       	sbi	0x04, 5	; 4
	DDR_SCK  |= (_BV(BIT_SCK));
 2c8:	27 9a       	sbi	0x04, 7	; 4
	#if !(RFM12_SPI_SOFTWARE)
		PORT_SPI |= (_BV(BIT_SPI_SS));
 2ca:	2c 9a       	sbi	0x05, 4	; 5
		DDR_SPI  |= (_BV(BIT_SPI_SS));
 2cc:	24 9a       	sbi	0x04, 4	; 4
	#endif

	DDR_MISO &= ~(_BV(BIT_MISO));
 2ce:	26 98       	cbi	0x04, 6	; 4

	#if !(RFM12_SPI_SOFTWARE)
		SPCR = (1<<SPE) | (1<<MSTR) | (1<<SPR0); //SPI Master, clk/16
 2d0:	81 e5       	ldi	r24, 0x51	; 81
 2d2:	8c bd       	out	0x2c, r24	; 44
	#endif

	//store the syncronization pattern to the transmission buffer
	//the sync pattern is used by the receiver to distinguish noise from real transmissions
	//the sync pattern is hardcoded into the receiver
	rf_tx_buffer.sync[0] = SYNC_MSB;
 2d4:	8d e2       	ldi	r24, 0x2D	; 45
 2d6:	80 93 18 02 	sts	0x0218, r24
	rf_tx_buffer.sync[1] = SYNC_LSB;
 2da:	84 ed       	ldi	r24, 0xD4	; 212
 2dc:	80 93 19 02 	sts	0x0219, r24

	//if receive mode is not disabled (default)
	#if !(RFM12_TRANSMIT_ONLY)
		//init buffer pointers
		ctrl.buffer_in_num = 0;
 2e0:	10 92 ca 01 	sts	0x01CA, r1
		ctrl.buffer_out_num = 0;
 2e4:	10 92 cb 01 	sts	0x01CB, r1
	#endif


	#if RFM12_LIVECTRL
		//init shadow registers with values about to be written to rfm12
		ctrl.rxctrl_shadow = RFM12_CMD_RXCTRL_DEFAULT;
 2e8:	8d e2       	ldi	r24, 0x2D	; 45
 2ea:	94 e9       	ldi	r25, 0x94	; 148
 2ec:	90 93 cd 01 	sts	0x01CD, r25
 2f0:	80 93 cc 01 	sts	0x01CC, r24
		ctrl.afc_shadow = RFM12_CMD_AFC_DEFAULT;
 2f4:	87 ef       	ldi	r24, 0xF7	; 247
 2f6:	94 ec       	ldi	r25, 0xC4	; 196
 2f8:	90 93 cf 01 	sts	0x01CF, r25
 2fc:	80 93 ce 01 	sts	0x01CE, r24
		ctrl.txconf_shadow = RFM12_CMD_TXCONF_DEFAULT;
 300:	80 e7       	ldi	r24, 0x70	; 112
 302:	98 e9       	ldi	r25, 0x98	; 152
 304:	90 93 d1 01 	sts	0x01D1, r25
 308:	80 93 d0 01 	sts	0x01D0, r24
		ctrl.cfg_shadow =    RFM12_CMD_CFG_DEFAULT;
 30c:	86 ed       	ldi	r24, 0xD6	; 214
 30e:	90 e8       	ldi	r25, 0x80	; 128
 310:	90 93 d3 01 	sts	0x01D3, r25
 314:	80 93 d2 01 	sts	0x01D2, r24
 318:	cc e7       	ldi	r28, 0x7C	; 124
 31a:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t x;

	#ifdef __PLATFORM_AVR__

		for (x = 0; x < ( sizeof(init_cmds) / 2) ; x++) {
			rfm12_data(pgm_read_word(&init_cmds[x]));
 31c:	fe 01       	movw	r30, r28
 31e:	85 91       	lpm	r24, Z+
 320:	94 91       	lpm	r25, Z
 322:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZL10rfm12_dataj>
 326:	22 96       	adiw	r28, 0x02	; 2
	//write all the initialisation values to rfm12
	uint8_t x;

	#ifdef __PLATFORM_AVR__

		for (x = 0; x < ( sizeof(init_cmds) / 2) ; x++) {
 328:	80 e0       	ldi	r24, 0x00	; 0
 32a:	c4 39       	cpi	r28, 0x94	; 148
 32c:	d8 07       	cpc	r29, r24
 32e:	b1 f7       	brne	.-20     	; 0x31c <rfm12_init+0x5e>
		adc_init();
	#endif

	//setup interrupt for falling edge trigger
#ifdef __PLATFORM_AVR__
	RFM12_INT_SETUP();
 330:	80 91 69 00 	lds	r24, 0x0069
 334:	80 62       	ori	r24, 0x20	; 32
 336:	80 93 69 00 	sts	0x0069, r24
#endif

	//clear int flag
	rfm12_read(RFM12_CMD_STATUS);
 33a:	80 e0       	ldi	r24, 0x00	; 0
 33c:	90 e0       	ldi	r25, 0x00	; 0
 33e:	0e 94 74 00 	call	0xe8	; 0xe8 <_ZL10rfm12_readj>

#ifdef __PLATFORM_AVR__
	RFM12_INT_FLAG = (1<<RFM12_FLAG_BIT);
 342:	84 e0       	ldi	r24, 0x04	; 4
 344:	8c bb       	out	0x1c, r24	; 28
#endif

	//init receiver fifo, we now begin receiving.
	rfm12_data(CLEAR_FIFO);
 346:	81 e8       	ldi	r24, 0x81	; 129
 348:	9a ec       	ldi	r25, 0xCA	; 202
 34a:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZL10rfm12_dataj>
	rfm12_data(ACCEPT_DATA);
 34e:	83 e8       	ldi	r24, 0x83	; 131
 350:	9a ec       	ldi	r25, 0xCA	; 202
 352:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZL10rfm12_dataj>

	//activate the interrupt
	RFM12_INT_ON();
 356:	ea 9a       	sbi	0x1d, 2	; 29
}
 358:	df 91       	pop	r29
 35a:	cf 91       	pop	r28
 35c:	08 95       	ret

0000035e <_Z10init_uart0v>:

void init_uart0 (void)
{
	/* Configure 9600 baud , 8-bit , no parity and one stop bit */
	const int baud_rate = 9600;
	UBRR0H = (F_CPU/(baud_rate*16L)-1) >> 8;
 35e:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = (F_CPU/(baud_rate*16L)-1);
 362:	8d e4       	ldi	r24, 0x4D	; 77
 364:	80 93 c4 00 	sts	0x00C4, r24
	UCSR0B = _BV(RXEN0) | _BV(TXEN0);
 368:	88 e1       	ldi	r24, 0x18	; 24
 36a:	80 93 c1 00 	sts	0x00C1, r24
	UCSR0C = _BV(UCSZ00) | _BV(UCSZ01);
 36e:	86 e0       	ldi	r24, 0x06	; 6
 370:	80 93 c2 00 	sts	0x00C2, r24
 374:	08 95       	ret

00000376 <_Z6get_chv>:
}

char get_ch (void)
{
	while (!( UCSR0A & _BV(RXC0)));
 376:	80 91 c0 00 	lds	r24, 0x00C0
 37a:	87 ff       	sbrs	r24, 7
 37c:	fc cf       	rjmp	.-8      	; 0x376 <_Z6get_chv>
	return UDR0 ;
 37e:	80 91 c6 00 	lds	r24, 0x00C6
}
 382:	08 95       	ret

00000384 <_Z6put_chc>:
void put_ch ( char ch)
{
	while (!(UCSR0A & _BV(UDRE0)));
 384:	90 91 c0 00 	lds	r25, 0x00C0
 388:	95 ff       	sbrs	r25, 5
 38a:	fc cf       	rjmp	.-8      	; 0x384 <_Z6put_chc>
	UDR0 = ch;
 38c:	80 93 c6 00 	sts	0x00C6, r24
 390:	08 95       	ret

00000392 <_Z7put_strPc>:
}

void put_str (char *str)
{
 392:	cf 93       	push	r28
 394:	df 93       	push	r29
 396:	ec 01       	movw	r28, r24
	int i;
	for (i=0; str[i]; i++) put_ch(str[i]);
 398:	89 91       	ld	r24, Y+
 39a:	88 23       	and	r24, r24
 39c:	19 f0       	breq	.+6      	; 0x3a4 <_Z7put_strPc+0x12>
 39e:	0e 94 c2 01 	call	0x384	; 0x384 <_Z6put_chc>
 3a2:	fa cf       	rjmp	.-12     	; 0x398 <_Z7put_strPc+0x6>
}
 3a4:	df 91       	pop	r29
 3a6:	cf 91       	pop	r28
 3a8:	08 95       	ret

000003aa <rfm12_tick>:
* This function also fills the rfm12 tx fifo with a preamble.
*
* \warning Warning, if you do not call this function periodically, then no packet will get transmitted.
* \see rfm12_tx() and rfm12_start_tx()
*/
void rfm12_tick(void) {
 3aa:	cf 93       	push	r28
	#endif

	//debug
	#if RFM12_UART_DEBUG
		static uint8_t oldstate;
		uint8_t state = ctrl.rfm12_state;
 3ac:	c0 91 c6 01 	lds	r28, 0x01C6
		if (oldstate != state) {
 3b0:	80 91 3b 02 	lds	r24, 0x023B
 3b4:	8c 17       	cp	r24, r28
 3b6:	c1 f0       	breq	.+48     	; 0x3e8 <rfm12_tick+0x3e>
			put_str("mode change: ");
 3b8:	8f e3       	ldi	r24, 0x3F	; 63
 3ba:	91 e0       	ldi	r25, 0x01	; 1
 3bc:	0e 94 c9 01 	call	0x392	; 0x392 <_Z7put_strPc>
			switch (state) {
 3c0:	c1 30       	cpi	r28, 0x01	; 1
 3c2:	39 f0       	breq	.+14     	; 0x3d2 <rfm12_tick+0x28>
 3c4:	20 f0       	brcs	.+8      	; 0x3ce <rfm12_tick+0x24>
 3c6:	c2 30       	cpi	r28, 0x02	; 2
 3c8:	31 f4       	brne	.+12     	; 0x3d6 <rfm12_tick+0x2c>
					break;
				case STATE_RX_ACTIVE:
					put_ch ('r');
					break;
				case STATE_TX:
					put_ch ('t');
 3ca:	84 e7       	ldi	r24, 0x74	; 116
 3cc:	05 c0       	rjmp	.+10     	; 0x3d8 <rfm12_tick+0x2e>
		uint8_t state = ctrl.rfm12_state;
		if (oldstate != state) {
			put_str("mode change: ");
			switch (state) {
				case STATE_RX_IDLE:
					put_ch ('i');
 3ce:	89 e6       	ldi	r24, 0x69	; 105
 3d0:	03 c0       	rjmp	.+6      	; 0x3d8 <rfm12_tick+0x2e>
					break;
				case STATE_RX_ACTIVE:
					put_ch ('r');
 3d2:	82 e7       	ldi	r24, 0x72	; 114
 3d4:	01 c0       	rjmp	.+2      	; 0x3d8 <rfm12_tick+0x2e>
					break;
				case STATE_TX:
					put_ch ('t');
					break;
				default:
					put_ch ('?');
 3d6:	8f e3       	ldi	r24, 0x3F	; 63
 3d8:	0e 94 c2 01 	call	0x384	; 0x384 <_Z6put_chc>
			}
			put_str ("\r\n");
 3dc:	8b e5       	ldi	r24, 0x5B	; 91
 3de:	91 e0       	ldi	r25, 0x01	; 1
 3e0:	0e 94 c9 01 	call	0x392	; 0x392 <_Z7put_strPc>
			oldstate = state;
 3e4:	c0 93 3b 02 	sts	0x023B, r28
		}
	#endif

	//don't disturb RFM12 if transmitting or receiving
	if (ctrl.rfm12_state != STATE_RX_IDLE) {
 3e8:	80 91 c6 01 	lds	r24, 0x01C6
 3ec:	81 11       	cpse	r24, r1
 3ee:	32 c0       	rjmp	.+100    	; 0x454 <rfm12_tick+0xaa>
	#if !(RFM12_NOCOLLISIONDETECTION)
		//disable the interrupt (as we're working directly with the transceiver now)
		//hint: we could be losing an interrupt here, because we read the status register.
		//this applys for the Wakeup timer, as it's flag is reset by reading.
		//printf("t");
		RFM12_INT_OFF();
 3f0:	ea 98       	cbi	0x1d, 2	; 29
		status = rfm12_read(RFM12_CMD_STATUS);
 3f2:	80 e0       	ldi	r24, 0x00	; 0
 3f4:	90 e0       	ldi	r25, 0x00	; 0
 3f6:	0e 94 74 00 	call	0xe8	; 0xe8 <_ZL10rfm12_readj>
		RFM12_INT_ON();
 3fa:	ea 9a       	sbi	0x1d, 2	; 29

		//check if we see a carrier
		if (status & RFM12_STATUS_RSSI) {
 3fc:	90 ff       	sbrs	r25, 0
 3fe:	02 c0       	rjmp	.+4      	; 0x404 <rfm12_tick+0x5a>
			//yes: reset free counter and return
			//puts("yes");
		//	printf("%u\n", status & RFM12_STATUS_RSSI);
			channel_free_count = CHANNEL_FREE_TIME;
 400:	88 ec       	ldi	r24, 0xC8	; 200
 402:	05 c0       	rjmp	.+10     	; 0x40e <rfm12_tick+0x64>
			return;
		}
		//no

		//is the channel free long enough ?
		if (channel_free_count != 0) {
 404:	80 91 00 01 	lds	r24, 0x0100
 408:	88 23       	and	r24, r24
 40a:	21 f0       	breq	.+8      	; 0x414 <rfm12_tick+0x6a>
			//no:
			channel_free_count--; // decrement counter
 40c:	81 50       	subi	r24, 0x01	; 1
 40e:	80 93 00 01 	sts	0x0100, r24
			return;
 412:	20 c0       	rjmp	.+64     	; 0x454 <rfm12_tick+0xaa>
	//	puts("trans");
		//yes: we can begin transmitting
	#endif
	//puts("trans");
	//do we have something to transmit?
	if (ctrl.txstate == STATUS_OCCUPIED) { //yes: start transmitting
 414:	80 91 c7 01 	lds	r24, 0x01C7
 418:	81 30       	cpi	r24, 0x01	; 1
 41a:	e1 f4       	brne	.+56     	; 0x454 <rfm12_tick+0xaa>
		//we won't loose interrupts, as the AVR caches them in the int flag.
		//we could disturb an ongoing reception,
		//if it has just started some cpu cycles ago
		//(as the check for this case is some lines (cpu cycles) above)
		//anyhow, we MUST transmit at some point...
		RFM12_INT_OFF();
 41c:	ea 98       	cbi	0x1d, 2	; 29

		#if RFM12_PWRMGT_SHADOW
			ctrl.pwrmgt_shadow &= ~(RFM12_PWRMGT_ER); /* disable receiver */
			rfm12_data(ctrl.pwrmgt_shadow);
		#else
			rfm12_data(RFM12_CMD_PWRMGT | PWRMGT_DEFAULT ); /* disable receiver */
 41e:	81 e0       	ldi	r24, 0x01	; 1
 420:	92 e8       	ldi	r25, 0x82	; 130
 422:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZL10rfm12_dataj>
			RX_LEAVE_HOOK;
		#endif

		//calculate number of bytes to be sent by ISR
		//2 sync bytes + len byte + type byte + checksum + message length + 1 dummy byte
		ctrl.num_bytes = rf_tx_buffer.len + 6;
 426:	80 91 1a 02 	lds	r24, 0x021A
 42a:	8a 5f       	subi	r24, 0xFA	; 250
 42c:	80 93 c8 01 	sts	0x01C8, r24

		//reset byte sent counter
		ctrl.bytecount = 0;
 430:	10 92 c9 01 	sts	0x01C9, r1

		//set mode for interrupt handler
		ctrl.rfm12_state = STATE_TX;
 434:	82 e0       	ldi	r24, 0x02	; 2
 436:	80 93 c6 01 	sts	0x01C6, r24
		#endif

		//fill 2byte 0xAA preamble into data register
		//the preamble helps the receivers AFC circuit to lock onto the exact frequency
		//(hint: the tx FIFO [if el is enabled] is two staged, so we can safely write 2 bytes before starting)
		rfm12_data(RFM12_CMD_TX | PREAMBLE);
 43a:	8a ea       	ldi	r24, 0xAA	; 170
 43c:	98 eb       	ldi	r25, 0xB8	; 184
 43e:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZL10rfm12_dataj>
		rfm12_data(RFM12_CMD_TX | PREAMBLE);
 442:	8a ea       	ldi	r24, 0xAA	; 170
 444:	98 eb       	ldi	r25, 0xB8	; 184
 446:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZL10rfm12_dataj>
		//set ET in power register to enable transmission (hint: TX starts now)
		#if RFM12_PWRMGT_SHADOW
			ctrl.pwrmgt_shadow |= RFM12_PWRMGT_ET;
			rfm12_data (ctrl.pwrmgt_shadow);
		#else
			rfm12_data(RFM12_CMD_PWRMGT | PWRMGT_DEFAULT | RFM12_PWRMGT_ET);
 44a:	81 e2       	ldi	r24, 0x21	; 33
 44c:	92 e8       	ldi	r25, 0x82	; 130
 44e:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZL10rfm12_dataj>
		#endif

		//enable the interrupt to continue the transmission
		RFM12_INT_ON();
 452:	ea 9a       	sbi	0x1d, 2	; 29
	}
}
 454:	cf 91       	pop	r28
 456:	08 95       	ret

00000458 <rfm12_tx>:
 458:	0f 93       	push	r16
 45a:	1f 93       	push	r17
 45c:	cf 93       	push	r28
 45e:	df 93       	push	r29
 460:	18 2f       	mov	r17, r24
 462:	06 2f       	mov	r16, r22
 464:	ea 01       	movw	r28, r20
 466:	8d e4       	ldi	r24, 0x4D	; 77
 468:	91 e0       	ldi	r25, 0x01	; 1
 46a:	0e 94 c9 01 	call	0x392	; 0x392 <_Z7put_strPc>
 46e:	1f 31       	cpi	r17, 0x1F	; 31
 470:	98 f4       	brcc	.+38     	; 0x498 <rfm12_tx+0x40>
 472:	80 91 c7 01 	lds	r24, 0x01C7
 476:	81 11       	cpse	r24, r1
 478:	11 c0       	rjmp	.+34     	; 0x49c <rfm12_tx+0x44>
 47a:	41 2f       	mov	r20, r17
 47c:	50 e0       	ldi	r21, 0x00	; 0
 47e:	be 01       	movw	r22, r28
 480:	8d e1       	ldi	r24, 0x1D	; 29
 482:	92 e0       	ldi	r25, 0x02	; 2
 484:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <memcpy>
 488:	61 2f       	mov	r22, r17
 48a:	80 2f       	mov	r24, r16
 48c:	df 91       	pop	r29
 48e:	cf 91       	pop	r28
 490:	1f 91       	pop	r17
 492:	0f 91       	pop	r16
 494:	0c 94 3e 01 	jmp	0x27c	; 0x27c <rfm12_start_tx>
 498:	82 e0       	ldi	r24, 0x02	; 2
 49a:	01 c0       	rjmp	.+2      	; 0x49e <rfm12_tx+0x46>
 49c:	83 e0       	ldi	r24, 0x03	; 3
 49e:	df 91       	pop	r29
 4a0:	cf 91       	pop	r28
 4a2:	1f 91       	pop	r17
 4a4:	0f 91       	pop	r16
 4a6:	08 95       	ret

000004a8 <main>:
 4a8:	cf 93       	push	r28
 4aa:	df 93       	push	r29
 4ac:	cd b7       	in	r28, 0x3d	; 61
 4ae:	de b7       	in	r29, 0x3e	; 62
 4b0:	27 97       	sbiw	r28, 0x07	; 7
 4b2:	0f b6       	in	r0, 0x3f	; 63
 4b4:	f8 94       	cli
 4b6:	de bf       	out	0x3e, r29	; 62
 4b8:	0f be       	out	0x3f, r0	; 63
 4ba:	cd bf       	out	0x3d, r28	; 61
 4bc:	0e 94 af 01 	call	0x35e	; 0x35e <_Z10init_uart0v>
 4c0:	2f e7       	ldi	r18, 0x7F	; 127
 4c2:	89 ea       	ldi	r24, 0xA9	; 169
 4c4:	93 e0       	ldi	r25, 0x03	; 3
 4c6:	21 50       	subi	r18, 0x01	; 1
 4c8:	80 40       	sbci	r24, 0x00	; 0
 4ca:	90 40       	sbci	r25, 0x00	; 0
 4cc:	e1 f7       	brne	.-8      	; 0x4c6 <main+0x1e>
 4ce:	00 c0       	rjmp	.+0      	; 0x4d0 <main+0x28>
 4d0:	00 00       	nop
 4d2:	0e 94 5f 01 	call	0x2be	; 0x2be <rfm12_init>
 4d6:	2f e7       	ldi	r18, 0x7F	; 127
 4d8:	89 ea       	ldi	r24, 0xA9	; 169
 4da:	93 e0       	ldi	r25, 0x03	; 3
 4dc:	21 50       	subi	r18, 0x01	; 1
 4de:	80 40       	sbci	r24, 0x00	; 0
 4e0:	90 40       	sbci	r25, 0x00	; 0
 4e2:	e1 f7       	brne	.-8      	; 0x4dc <main+0x34>
 4e4:	00 c0       	rjmp	.+0      	; 0x4e6 <main+0x3e>
 4e6:	00 00       	nop
 4e8:	87 e0       	ldi	r24, 0x07	; 7
 4ea:	e8 e3       	ldi	r30, 0x38	; 56
 4ec:	f1 e0       	ldi	r31, 0x01	; 1
 4ee:	de 01       	movw	r26, r28
 4f0:	11 96       	adiw	r26, 0x01	; 1
 4f2:	01 90       	ld	r0, Z+
 4f4:	0d 92       	st	X+, r0
 4f6:	8a 95       	dec	r24
 4f8:	e1 f7       	brne	.-8      	; 0x4f2 <main+0x4a>
 4fa:	78 94       	sei
 4fc:	02 e2       	ldi	r16, 0x22	; 34
 4fe:	e0 91 cb 01 	lds	r30, 0x01CB
 502:	0e 9f       	mul	r16, r30
 504:	f0 01       	movw	r30, r0
 506:	11 24       	eor	r1, r1
 508:	ec 52       	subi	r30, 0x2C	; 44
 50a:	fe 4f       	sbci	r31, 0xFE	; 254
 50c:	80 81       	ld	r24, Z
 50e:	82 30       	cpi	r24, 0x02	; 2
 510:	39 f5       	brne	.+78     	; 0x560 <main+0xb8>
 512:	81 e0       	ldi	r24, 0x01	; 1
 514:	91 e0       	ldi	r25, 0x01	; 1
 516:	0e 94 c9 01 	call	0x392	; 0x392 <_Z7put_strPc>
 51a:	80 91 cb 01 	lds	r24, 0x01CB
 51e:	08 9f       	mul	r16, r24
 520:	c0 01       	movw	r24, r0
 522:	11 24       	eor	r1, r1
 524:	88 52       	subi	r24, 0x28	; 40
 526:	9e 4f       	sbci	r25, 0xFE	; 254
 528:	90 93 c5 01 	sts	0x01C5, r25
 52c:	80 93 c4 01 	sts	0x01C4, r24
 530:	10 e0       	ldi	r17, 0x00	; 0
 532:	e0 91 cb 01 	lds	r30, 0x01CB
 536:	0e 9f       	mul	r16, r30
 538:	f0 01       	movw	r30, r0
 53a:	11 24       	eor	r1, r1
 53c:	ec 52       	subi	r30, 0x2C	; 44
 53e:	fe 4f       	sbci	r31, 0xFE	; 254
 540:	81 81       	ldd	r24, Z+1	; 0x01
 542:	18 17       	cp	r17, r24
 544:	58 f4       	brcc	.+22     	; 0x55c <main+0xb4>
 546:	e0 91 c4 01 	lds	r30, 0x01C4
 54a:	f0 91 c5 01 	lds	r31, 0x01C5
 54e:	e1 0f       	add	r30, r17
 550:	f1 1d       	adc	r31, r1
 552:	80 81       	ld	r24, Z
 554:	0e 94 c2 01 	call	0x384	; 0x384 <_Z6put_chc>
 558:	1f 5f       	subi	r17, 0xFF	; 255
 55a:	eb cf       	rjmp	.-42     	; 0x532 <main+0x8a>
 55c:	0e 94 51 01 	call	0x2a2	; 0x2a2 <rfm12_rx_clear>
 560:	88 e2       	ldi	r24, 0x28	; 40
 562:	91 e0       	ldi	r25, 0x01	; 1
 564:	0e 94 c9 01 	call	0x392	; 0x392 <_Z7put_strPc>
 568:	84 e3       	ldi	r24, 0x34	; 52
 56a:	91 e0       	ldi	r25, 0x01	; 1
 56c:	0e 94 c9 01 	call	0x392	; 0x392 <_Z7put_strPc>
 570:	ae 01       	movw	r20, r28
 572:	4f 5f       	subi	r20, 0xFF	; 255
 574:	5f 4f       	sbci	r21, 0xFF	; 255
 576:	60 e0       	ldi	r22, 0x00	; 0
 578:	87 e0       	ldi	r24, 0x07	; 7
 57a:	0e 94 2c 02 	call	0x458	; 0x458 <rfm12_tx>
 57e:	14 e6       	ldi	r17, 0x64	; 100
 580:	0e 94 d5 01 	call	0x3aa	; 0x3aa <rfm12_tick>
 584:	8b ed       	ldi	r24, 0xDB	; 219
 586:	95 e0       	ldi	r25, 0x05	; 5
 588:	01 97       	sbiw	r24, 0x01	; 1
 58a:	f1 f7       	brne	.-4      	; 0x588 <main+0xe0>
 58c:	00 c0       	rjmp	.+0      	; 0x58e <main+0xe6>
 58e:	00 00       	nop
 590:	11 50       	subi	r17, 0x01	; 1
 592:	b1 f7       	brne	.-20     	; 0x580 <main+0xd8>
 594:	9f e7       	ldi	r25, 0x7F	; 127
 596:	2f e4       	ldi	r18, 0x4F	; 79
 598:	82 e1       	ldi	r24, 0x12	; 18
 59a:	91 50       	subi	r25, 0x01	; 1
 59c:	20 40       	sbci	r18, 0x00	; 0
 59e:	80 40       	sbci	r24, 0x00	; 0
 5a0:	e1 f7       	brne	.-8      	; 0x59a <main+0xf2>
 5a2:	00 c0       	rjmp	.+0      	; 0x5a4 <main+0xfc>
 5a4:	00 00       	nop
 5a6:	ab cf       	rjmp	.-170    	; 0x4fe <main+0x56>

000005a8 <memcpy>:
 5a8:	fb 01       	movw	r30, r22
 5aa:	dc 01       	movw	r26, r24
 5ac:	02 c0       	rjmp	.+4      	; 0x5b2 <memcpy+0xa>
 5ae:	01 90       	ld	r0, Z+
 5b0:	0d 92       	st	X+, r0
 5b2:	41 50       	subi	r20, 0x01	; 1
 5b4:	50 40       	sbci	r21, 0x00	; 0
 5b6:	d8 f7       	brcc	.-10     	; 0x5ae <memcpy+0x6>
 5b8:	08 95       	ret

000005ba <_exit>:
 5ba:	f8 94       	cli

000005bc <__stop_program>:
 5bc:	ff cf       	rjmp	.-2      	; 0x5bc <__stop_program>
